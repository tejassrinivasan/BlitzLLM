---
title: "GET /health"
description: "Check server health and MCP connection status"
openapi: "GET /health"
---

<Note>
  The health check endpoint does not require authentication and can be called without an API key.
</Note>

## Overview

The `/health` endpoint provides a comprehensive health check for the Blitz API, including the status of all critical services required for sports analysis.

## Service Components

<CardGroup cols={2}>
  <Card
    title="ðŸš€ API Server"
    icon="server"
  >
    **FastAPI Application**
    
    Main API server status and uptime information.
  </Card>
  
  <Card
    title="ðŸ”— MCP Server"
    icon="database"
  >
    **Model Context Protocol**
    
    Connection to the Blitz MCP server with available tools and database connectivity.
  </Card>
  
  <Card
    title="ðŸ§  Anthropic API"
    icon="brain"
  >
    **Claude 4 Sonnet**
    
    Advanced reasoning LLM models API connection and model availability.
  </Card>
  
  <Card
    title="ðŸ“Š Data Sources"
    icon="chart-line"
  >
    **Sports Databases**
    
    Historical NBA data, real-time feeds, and betting market connections.
  </Card>
</CardGroup>

## Health Status Levels

<AccordionGroup>
  <Accordion icon="check-circle" title="healthy">
    **All systems operational**
    - API server is running normally
    - MCP server is connected with all tools available
    - Anthropic API is accessible and responsive
    - Sports analysis requests will work optimally
    - All data sources are available
  </Accordion>
  
  <Accordion icon="exclamation-triangle" title="degraded">
    **Some non-critical issues present**
    - API server is running
    - MCP server may have limited functionality
    - Some data sources might be temporarily unavailable
    - Most analysis requests will still work
    - Some advanced features may be limited
  </Accordion>
  
  <Accordion icon="x-circle" title="unhealthy">
    **Critical issues prevent normal operation**
    - MCP server is disconnected, or
    - Anthropic API is unavailable, or
    - Database connections are down, or
    - Other critical services are failing
    - Analysis requests will likely fail
  </Accordion>
</AccordionGroup>

## Monitoring Integration

### Load Balancer Configuration

<CodeGroup>
```yaml NGINX
upstream blitzagent {
    server localhost:8001;
}

server {
    location /health {
        proxy_pass http://blitzagent/health;
        access_log off;
        proxy_cache off;
    }
    
    location / {
        proxy_pass http://blitzagent;
        
        # Health check-based routing
        error_page 502 503 504 @maintenance;
    }
    
    location @maintenance {
        return 503 "Service temporarily unavailable";
    }
}
```

```yaml Kubernetes Health Probes
apiVersion: apps/v1
kind: Deployment
metadata:
  name: blitzagent
spec:
  replicas: 3
  selector:
    matchLabels:
      app: blitzagent
  template:
    metadata:
      labels:
        app: blitzagent
    spec:
      containers:
      - name: blitzagent
        image: blitzagent:latest
        ports:
        - containerPort: 8001
        livenessProbe:
          httpGet:
            path: /health
            port: 8001
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /health
            port: 8001
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          successThreshold: 1
          failureThreshold: 3
```

```yaml Docker Compose
version: '3.8'
services:
  blitzagent:
    image: blitzagent:latest
    ports:
      - "8001:8001"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8001/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    environment:
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - API_KEY=${API_KEY}
    restart: unless-stopped
```
</CodeGroup>

### Application Monitoring

<CodeGroup>
```python Python Health Monitor
import asyncio
import httpx
import logging
from datetime import datetime
from typing import Dict, Optional

class BlitzHealthMonitor:
    def __init__(self, base_url: str = "https://blitzagent.onrender.com"):
        self.base_url = base_url
        self.logger = logging.getLogger(__name__)
        self.alert_callback = None
    
    async def check_health(self) -> Dict:
        """Perform a single health check"""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.base_url}/health",
                    timeout=10.0
                )
                response.raise_for_status()
                return response.json()
        except Exception as e:
            self.logger.error(f"Health check failed: {e}")
            return {
                "status": "unhealthy", 
                "error": str(e),
                "timestamp": datetime.utcnow().isoformat()
            }
    
    async def monitor_continuously(self, interval: int = 60):
        """Continuously monitor health with alerting"""
        consecutive_failures = 0
        
        while True:
            health = await self.check_health()
            status = health.get("status", "unknown")
            
            if status == "healthy":
                consecutive_failures = 0
                self.logger.info("âœ… Blitz is healthy")
            elif status == "degraded":
                consecutive_failures = 0
                self.logger.warning("âš ï¸ Blitz is degraded")
                if self.alert_callback:
                    await self.alert_callback("degraded", health)
            else:
                consecutive_failures += 1
                self.logger.error(f"âŒ Blitz is unhealthy (failure #{consecutive_failures})")
                if self.alert_callback:
                    await self.alert_callback("unhealthy", health)
            
            # Log detailed service status
            if "services" in health:
                services = health["services"]
                self.logger.debug(f"Service status: {services}")
                
                # Check individual services
                for service_name, service_data in services.items():
                    service_status = service_data.get("status", "unknown")
                    if service_status not in ["up", "connected", "available"]:
                        self.logger.warning(f"Service {service_name} is {service_status}")
            
            await asyncio.sleep(interval)
    
    def set_alert_callback(self, callback):
        """Set callback function for health alerts"""
        self.alert_callback = callback

# Example usage
async def health_alert_handler(status: str, health_data: Dict):
    """Handle health alerts"""
    if status == "unhealthy":
        # Send critical alert
        print(f"CRITICAL: Blitz is unhealthy - {health_data}")
        # Integration with alerting systems (Slack, PagerDuty, etc.)
    elif status == "degraded":
        # Send warning alert
        print(f"WARNING: Blitz is degraded - {health_data}")

# Start monitoring
monitor = BlitzHealthMonitor()
monitor.set_alert_callback(health_alert_handler)
await monitor.monitor_continuously(interval=30)
```

```javascript JavaScript Health Monitor
class BlitzHealthMonitor {
  constructor(baseUrl = 'https://blitzagent.onrender.com') {
    this.baseUrl = baseUrl;
    this.alertCallback = null;
    this.consecutiveFailures = 0;
  }

  async checkHealth() {
    try {
      const response = await fetch(`${this.baseUrl}/health`, {
        method: 'GET',
        timeout: 10000
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return await response.json();
    } catch (error) {
      console.error('Health check failed:', error);
      return {
        status: 'unhealthy',
        error: error.message,
        timestamp: new Date().toISOString()
      };
    }
  }

  async monitorContinuously(interval = 60000) {
    const monitor = async () => {
      const health = await this.checkHealth();
      const status = health.status || 'unknown';

      switch (status) {
        case 'healthy':
          this.consecutiveFailures = 0;
          console.log('âœ… Blitz is healthy');
          break;
        case 'degraded':
          this.consecutiveFailures = 0;
          console.warn('âš ï¸ Blitz is degraded');
          if (this.alertCallback) {
            this.alertCallback('degraded', health);
          }
          break;
        default:
          this.consecutiveFailures++;
          console.error(`âŒ Blitz is unhealthy (failure #${this.consecutiveFailures})`);
          if (this.alertCallback) {
            this.alertCallback('unhealthy', health);
          }
      }

      // Log service details
      if (health.services) {
        Object.entries(health.services).forEach(([serviceName, serviceData]) => {
          const serviceStatus = serviceData.status || 'unknown';
          if (!['up', 'connected', 'available'].includes(serviceStatus)) {
            console.warn(`Service ${serviceName} is ${serviceStatus}`);
          }
        });
      }
    };

    // Initial check
    await monitor();
    
    // Set up recurring monitoring
    setInterval(monitor, interval);
  }

  setAlertCallback(callback) {
    this.alertCallback = callback;
  }
}

// Example alert handler
const handleHealthAlert = (status, healthData) => {
  if (status === 'unhealthy') {
    // Send critical alert (integrate with your alerting system)
    console.error('CRITICAL: Blitz is unhealthy', healthData);
  } else if (status === 'degraded') {
    // Send warning alert
    console.warn('WARNING: Blitz is degraded', healthData);
  }
};

// Start monitoring
const monitor = new BlitzHealthMonitor();
monitor.setAlertCallback(handleHealthAlert);
monitor.monitorContinuously(30000); // Check every 30 seconds
```
</CodeGroup>

## Troubleshooting Common Issues

<AccordionGroup>
  <Accordion icon="database" title="MCP Server Connection Issues">
    **Symptoms:**
    - `mcp_server.status` shows `disconnected` or `error`
    - `tools_available` is 0 or very low
    - Analysis requests fail with database errors
    
    **Solutions:**
    1. **Check Network Connectivity**: Verify internet access from server
    2. **Validate Environment Variables**: Ensure MCP credentials are correct
    3. **Restart Services**: Restart Blitz application
    4. **Check MCP Server Logs**: Look for connection timeout or auth errors
    5. **Verify Database Access**: Test direct database connectivity
  </Accordion>
  
  <Accordion icon="key" title="Anthropic API Issues">
    **Symptoms:**
    - `anthropic.status` shows `unavailable`
    - Error messages mention API key problems
    - Analysis requests return authentication errors
    
    **Solutions:**
    1. **Verify API Key**: Check `ANTHROPIC_API_KEY` environment variable
    2. **Test API Key**: Validate at [Anthropic Console](https://console.anthropic.com/)
    3. **Check Credits**: Ensure sufficient API credits/quota
    4. **Rate Limiting**: Wait if you've hit rate limits
    5. **Model Access**: Verify access to Claude 4 Sonnet model
  </Accordion>
  
  <Accordion icon="server" title="API Server Problems">
    **Symptoms:**
    - Cannot reach `/health` endpoint
    - Connection timeouts or HTTP errors
    - Server returns 5xx status codes
    
    **Solutions:**
    1. **Process Status**: Check if Blitz process is running
    2. **Port Access**: Verify port 8001 is accessible
    3. **Firewall Rules**: Check firewall configurations
    4. **Server Logs**: Review application logs for errors
    5. **Resource Usage**: Monitor CPU, memory, and disk usage
    6. **Environment Setup**: Verify all required environment variables
  </Accordion>
  
  <Accordion icon="chart-line" title="Performance Degradation">
    **Symptoms:**
    - Health checks take longer than usual
    - `degraded` status appears frequently
    - Slow response times for analysis
    
    **Solutions:**
    1. **Resource Monitoring**: Check CPU, memory, and network usage
    2. **Database Performance**: Monitor query execution times
    3. **API Rate Limits**: Verify not hitting external API limits
    4. **Concurrent Requests**: Monitor concurrent analysis requests
    5. **Service Scaling**: Consider horizontal or vertical scaling
  </Accordion>
</AccordionGroup>

## Monitoring Best Practices

<AccordionGroup>
  <Accordion icon="clock" title="Check Frequency">
    **Recommended Intervals:**
    - **Production Load Balancers**: 5-10 seconds
    - **Application Monitoring**: 30-60 seconds  
    - **Development Environment**: 2-5 minutes
    - **User Interface Health**: 10-30 seconds
    
    **Considerations:**
    - Implement exponential backoff for failed checks
    - Use different intervals for different components
    - Adjust frequency based on system load
  </Accordion>
  
  <Accordion icon="bell" title="Alerting Strategy">
    **Alert Thresholds:**
    - **Immediate Alert**: `unhealthy` status
    - **Warning Alert**: `degraded` status for 5+ minutes
    - **Critical Alert**: 3+ consecutive health check failures
    - **Recovery Alert**: Return to `healthy` status
    
    **Alert Content:**
    - Include full health check response
    - Provide troubleshooting links
    - Set up escalation paths
    - Include system metrics and logs
  </Accordion>
  
  <Accordion icon="chart-bar" title="Metrics and Dashboards">
    **Key Metrics to Track:**
    - Health check response time trends
    - Service availability percentages
    - Error rate by service component
    - Recovery time from incidents
    
    **Dashboard Components:**
    - Real-time health status overview
    - Historical uptime charts
    - Service dependency mapping
    - Alert frequency and patterns
  </Accordion>
</AccordionGroup>

## Integration Examples

### Uptime Monitoring Services

<CodeGroup>
```yaml Uptime Robot Configuration
# Monitor URL: https://blitzagent.onrender.com/health
# Check Type: HTTP(s)
# Interval: 5 minutes
# Timeout: 30 seconds
# HTTP Method: GET
# Expected Status Code: 200
# Expected Content: "healthy"
```

```javascript Pingdom Integration
// Custom Pingdom check script
const response = http.get('https://blitzagent.onrender.com/health');

if (response.status === 200) {
  const health = JSON.parse(response.body);
  
  if (health.status === 'healthy') {
    console.log('OK: All services healthy');
  } else if (health.status === 'degraded') {
    console.log('WARNING: Service degraded');
  } else {
    console.log('CRITICAL: Service unhealthy');
    throw new Error('Health check failed');
  }
} else {
  throw new Error(`HTTP ${response.status}: Health endpoint unreachable`);
}
```

```python Datadog Integration
import httpx
from datadog import initialize, statsd

# Initialize Datadog
initialize()

async def datadog_health_check():
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get('https://blitzagent.onrender.com/health')
            health = response.json()
        
        # Send metrics to Datadog
        status_value = {
            'healthy': 1,
            'degraded': 0.5, 
            'unhealthy': 0
        }.get(health['status'], 0)
        
        statsd.gauge('blitz.health.overall', status_value)
        
        # Service-specific metrics
        if 'services' in health:
            for service, data in health['services'].items():
                service_value = 1 if data.get('status') in ['up', 'connected', 'available'] else 0
                statsd.gauge(f'blitz.health.{service}', service_value)
        
        # Response time
        statsd.timing('blitz.health.response_time', response.elapsed.total_seconds() * 1000)
        
    except Exception as e:
        statsd.gauge('blitz.health.overall', 0)
        statsd.increment('blitz.health.errors')
```
</CodeGroup>

## Related Information

<CardGroup cols={2}>
  <Card
    title="ðŸ”§ Troubleshooting Guide"
    icon="wrench"
    href="/troubleshooting"
  >
    Detailed troubleshooting for common Blitz issues
  </Card>
  
  <Card
    title="âš™ï¸ Configuration Guide"
    icon="cog"
    href="/configuration"
  >
    Learn how to configure Blitz for optimal performance
  </Card>
  
  <Card
    title="ðŸ“Š API Reference"
    icon="code"
    href="/api-reference/analyze"
  >
    Main analysis endpoint documentation
  </Card>
  
  <Card
    title="ðŸš€ Deployment Guide"
    icon="rocket"
    href="/development"
  >
    Production deployment best practices
  </Card>
</CardGroup>
