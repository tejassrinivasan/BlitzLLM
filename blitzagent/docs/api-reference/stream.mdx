---
title: "POST /analyze/stream"
description: "Stream real-time analysis events for sports queries"
openapi: "POST /analyze/stream"
---

<Warning>
  **Interactive Testing Limitation**: This endpoint uses Server-Sent Events (SSE) streaming, which cannot be tested in standard API playgrounds. Use the code examples below or the [Stream Viewer Tool](#stream-viewer-tool) for testing.
</Warning>

## Overview

The `/analyze/stream` endpoint provides real-time streaming of analysis events, allowing you to see Blitz's reasoning process as it happens. This is particularly useful for complex queries that may take time to process.

## Key Features

<CardGroup cols={2}>
  <Card
    title="ðŸ”„ Real-time Events"
    icon="stream"
  >
    **Live Analysis Progress**
    
    See each step of the analysis process as it happens, from league detection to final results.
  </Card>
  
  <Card
    title="ðŸ§  Reasoning Transparency"
    icon="brain"
  >
    **Claude 4 Sonnet Thinking**
    
    Watch advanced reasoning in action with thinking capabilities and step-by-step analysis.
  </Card>
  
  <Card
    title="âš¡ Tool Execution"
    icon="wrench"
  >
    **MCP Tool Calls**
    
    Monitor database queries, statistical calculations, and data retrieval in real-time.
  </Card>
  
  <Card
    title="ðŸ“Š Progress Tracking"
    icon="chart-line"
  >
    **Visual Progress**
    
    Progress indicators and status updates for long-running analyses.
  </Card>
</CardGroup>

## Event Types

The stream emits various event types throughout the analysis:

<AccordionGroup>
  <Accordion icon="play" title="analysis_start">
    **Analysis Initialization**
    
    Indicates the beginning of the analysis process with query details.
  </Accordion>
  
  <Accordion icon="target" title="league_detection">
    **Automatic League Detection**
    
    Shows when Blitz has automatically detected the sport/league from context clues.
  </Accordion>
  
  <Accordion icon="database" title="tool_call">
    **MCP Tool Execution**
    
    Real-time updates when MCP tools are being called for data retrieval or analysis.
  </Accordion>
  
  <Accordion icon="brain" title="model_reasoning">
    **Claude 4 Sonnet Reasoning**
    
    Advanced reasoning and thinking process with context analysis.
  </Accordion>
  
  <Accordion icon="download" title="tool_result">
    **Data Retrieval Results**
    
    Successful data retrieval from various sources with record counts and metadata.
  </Accordion>
  
  <Accordion icon="check" title="analysis_complete">
    **Final Results**
    
    Complete analysis response with usage statistics and final insights.
  </Accordion>
  
  <Accordion icon="exclamation-triangle" title="error">
    **Error Handling**
    
    Error events with detailed messages and retry suggestions.
  </Accordion>
</AccordionGroup>

## Implementation Examples

### Python AsyncIO Streaming

```python Python AsyncIO Client
import asyncio
import json
import httpx
from typing import AsyncGenerator, Dict, Any

class StreamingAnalysisClient:
    def __init__(self, api_key: str, base_url: str = "https://blitzagent.onrender.com"):
        self.api_key = api_key
        self.base_url = base_url
        self.headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }
    
    async def stream_analysis(
        self, 
        query: str, 
        extra_context: str = None
    ) -> AsyncGenerator[Dict[str, Any], None]:
        """Stream analysis events in real-time"""
        payload = {"query": query}
        if extra_context:
            payload["extra_context"] = extra_context
        
        async with httpx.AsyncClient() as client:
            async with client.stream(
                "POST",
                f"{self.base_url}/analyze/stream",
                headers=self.headers,
                json=payload
            ) as response:
                async for line in response.aiter_lines():
                    if line.startswith("data: "):
                        try:
                            event = json.loads(line[6:])
                            yield event
                            
                            if event['event_type'] == 'analysis_complete':
                                break
                        except json.JSONDecodeError:
                            continue

# Usage
async def main():
    client = StreamingAnalysisClient("your_api_key")
    
    async for event in client.stream_analysis(
        "Compare LeBron James and Michael Jordan in playoff performances",
        "Include advanced metrics and clutch performance"
    ):
        print(f"[{event['event_type']}] {event['message']}")
        
        if event['event_type'] == 'analysis_complete':
            print("\nFinal Analysis:")
            print(event['data']['response'])

asyncio.run(main())
```

### React Hook for Streaming

```javascript React Streaming Hook
import { useState, useCallback } from 'react';

const useStreamingAnalysis = (apiKey) => {
  const [events, setEvents] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [finalResult, setFinalResult] = useState(null);
  const [error, setError] = useState(null);

  const streamAnalysis = useCallback(async (query, extraContext = null) => {
    setIsLoading(true);
    setEvents([]);
    setFinalResult(null);
    setError(null);

    try {
      const response = await fetch('https://blitzagent.onrender.com/analyze/stream', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({ 
          query, 
          extra_context: extraContext 
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const reader = response.body.getReader();
      
      const readStream = async () => {
        const { done, value } = await reader.read();
        if (done) {
          setIsLoading(false);
          return;
        }

        const chunk = new TextDecoder().decode(value);
        const lines = chunk.split('\n');

        lines.forEach(line => {
          if (line.startsWith('data: ')) {
            try {
              const event = JSON.parse(line.slice(6));
              setEvents(prev => [...prev, event]);
              
              if (event.event_type === 'analysis_complete') {
                setFinalResult(event.data.response);
                setIsLoading(false);
              } else if (event.event_type === 'error') {
                setError(event.message);
                setIsLoading(false);
              }
            } catch (e) {
              // Skip invalid JSON
            }
          }
        });

        if (!done) readStream();
      };

      readStream();
    } catch (err) {
      setError(err.message);
      setIsLoading(false);
    }
  }, [apiKey]);

  return { events, isLoading, finalResult, error, streamAnalysis };
};

// Usage in component
const SportsAnalysis = () => {
  const { events, isLoading, finalResult, error, streamAnalysis } = 
    useStreamingAnalysis('your_api_key');

  return (
    <div className="analysis-container">
      <button 
        onClick={() => streamAnalysis(
          "What are the best clutch performers in NBA history?",
          "Include statistical analysis and memorable moments"
        )}
        disabled={isLoading}
      >
        {isLoading ? 'Analyzing...' : 'Start Analysis'}
      </button>
      
      {error && (
        <div className="error">
          <strong>Error:</strong> {error}
        </div>
      )}
      
      <div className="events-stream">
        {events.map((event, index) => (
          <div key={index} className={`event ${event.event_type}`}>
            <span className="timestamp">
              {new Date(event.timestamp).toLocaleTimeString()}
            </span>
            <span className="type">[{event.event_type}]</span>
            <span className="message">{event.message}</span>
          </div>
        ))}
      </div>
      
      {finalResult && (
        <div className="final-result">
          <h3>Analysis Complete</h3>
          <div className="result-content">
            {finalResult}
          </div>
        </div>
      )}
    </div>
  );
};
```

### cURL with Real-time Output

```bash cURL Streaming
curl -X POST "https://blitzagent.onrender.com/analyze/stream" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_BLITZ_API_KEY" \
  -d '{
    "query": "Analyze the evolution of three-point shooting in the NBA",
    "extra_context": "Include historical trends and impact on strategy"
  }' \
  --no-buffer -s | while read line; do
    if [[ $line == data:* ]]; then
      echo $line | sed 's/^data: //' | jq -r '"[\(.event_type)] \(.message)"'
    fi
  done
```

## Stream Viewer Tool

Blitz includes a built-in interactive stream viewer for testing:

<Steps>
  <Step title="Access Stream Viewer">
    Navigate to the stream viewer:
    ```
    https://blitzagent.onrender.com/stream_viewer.html
    ```
  </Step>
  
  <Step title="Configure Settings">
    - Enter your Blitz API key
    - Optionally filter event types
    - Set up progress tracking preferences
  </Step>
  
  <Step title="Test Streaming Analysis">
    - Enter a sports analysis query
    - Add optional context
    - Watch real-time events stream
    - View final analysis results
  </Step>
</Steps>

<Card
  title="Stream Viewer Features"
  icon="play"
>
  - **Real-time Event Display**: See each analysis step as it happens
  - **Event Filtering**: Choose which event types to display  
  - **Progress Visualization**: Visual progress bars and status indicators
  - **Error Handling**: Clear error messages with retry options
  - **Result Export**: Save analysis results and event logs
  - **Performance Metrics**: Track response times and token usage
</Card>

## Best Practices

<AccordionGroup>
  <Accordion icon="zap" title="When to Use Streaming">
    **Ideal Use Cases:**
    - Complex multi-dimensional analyses (15+ seconds)
    - User interfaces requiring progress feedback
    - Debugging analysis workflows
    - Real-time dashboards and monitoring
    - Educational tools showing AI reasoning
  </Accordion>
  
  <Accordion icon="code" title="Implementation Guidelines">
    **Technical Best Practices:**
    - Always handle JSON parsing errors gracefully
    - Implement proper connection management
    - Buffer events for smooth UI updates
    - Show progress indicators based on event types
    - Handle stream interruptions and reconnection
    - Use connection pooling for multiple requests
  </Accordion>
  
  <Accordion icon="performance" title="Performance Optimization">
    **Efficiency Considerations:**
    - Streaming has slight overhead vs `/analyze`
    - Cache repeated similar queries when possible
    - Use appropriate timeout values
    - Monitor client-side memory usage for long streams
    - Implement proper cleanup for interrupted streams
  </Accordion>
</AccordionGroup>

## Error Handling

Stream errors are sent as regular events with detailed information:

```json Example Error Event
{
  "event_type": "error",
  "message": "Database connection timeout - retrying with backup",
  "data": {
    "error_type": "connection_timeout",
    "error_code": "DB_TIMEOUT",
    "retry_possible": true,
    "retry_delay": 2000,
    "fallback_available": true
  },
  "timestamp": "2024-01-15T10:30:10Z"
}
```

## Use Cases

<AccordionGroup>
  <Accordion icon="chart-line" title="Real-time Dashboards">
    **Sports Analytics Dashboards**
    
    Stream live analysis updates for dynamic sports dashboards with real-time insights.
  </Accordion>
  
  <Accordion icon="graduation-cap" title="Educational Applications">
    **AI Reasoning Education**
    
    Show students and researchers how advanced AI systems approach complex sports analysis problems.
  </Accordion>
  
  <Accordion icon="bug" title="Development & Debugging">
    **Analysis Workflow Debugging**
    
    Monitor the analysis process to optimize queries and understand performance characteristics.
  </Accordion>
  
  <Accordion icon="mobile" title="Mobile Applications">
    **Progressive Loading**
    
    Provide immediate feedback in mobile apps while complex analyses complete in the background.
  </Accordion>
</AccordionGroup>

## Related Endpoints

<CardGroup cols={2}>
  <Card
    title="POST /analyze"
    icon="search"
    href="/api-reference/analyze"
  >
    Standard analysis endpoint for simpler queries
  </Card>
  
  <Card
    title="GET /health"
    icon="heart"
    href="/api-reference/health"
  >
    Check server health before starting streams
  </Card>
</CardGroup>